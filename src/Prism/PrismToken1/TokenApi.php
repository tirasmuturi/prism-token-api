<?php
namespace Prism\PrismToken1;
/**
 * Autogenerated by Thrift Compiler (0.9.2)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
use Thrift\Base\TBase;
use Thrift\Type\TType;
use Thrift\Type\TMessageType;
use Thrift\Exception\TException;
use Thrift\Exception\TProtocolException;
use Thrift\Protocol\TProtocol;
use Thrift\Protocol\TBinaryProtocolAccelerated;
use Thrift\Exception\TApplicationException;


interface TokenApiIf {
  /**
   * @param int $sleepMs
   * @param string $echo
   * @return string
   * @throws \Prism\PrismToken1\ApiException
   */
  public function ping($sleepMs, $echo);
  /**
   * @param string $messageId
   * @param string $realm
   * @param string $username
   * @param string $password
   * @param \Prism\PrismToken1\SessionOptions $sessionOpts
   * @return \Prism\PrismToken1\SignInResult
   * @throws \Prism\PrismToken1\ApiException
   */
  public function signInWithPassword($messageId, $realm, $username, $password, \Prism\PrismToken1\SessionOptions $sessionOpts);
  /**
   * @param string $messageId
   * @param string $accessToken
   * @return \Prism\PrismToken1\NodeStatus[]
   * @throws \Prism\PrismToken1\ApiException
   */
  public function getStatus($messageId, $accessToken);
  /**
   * @param string $messageId
   * @param string $accessToken
   * @param string $idRecord
   * @return \Prism\PrismToken1\MeterConfigIn
   * @throws \Prism\PrismToken1\ApiException
   */
  public function parseIdRecord($messageId, $accessToken, $idRecord);
  /**
   * @param string $messageId
   * @param string $accessToken
   * @param \Prism\PrismToken1\MeterConfigIn $meterConfig
   * @param int $subclass
   * @param double $transferAmount
   * @param int $tokenTime
   * @param int $flags
   * @return \Prism\PrismToken1\Token[]
   * @throws \Prism\PrismToken1\ApiException
   */
  public function issueCreditToken($messageId, $accessToken, \Prism\PrismToken1\MeterConfigIn $meterConfig, $subclass, $transferAmount, $tokenTime, $flags);
  /**
   * @param string $messageId
   * @param string $accessToken
   * @param int $subclass
   * @param int $control
   * @param int $mfrcode
   * @return \Prism\PrismToken1\MeterTestToken
   * @throws \Prism\PrismToken1\ApiException
   */
  public function issueMeterTestToken($messageId, $accessToken, $subclass, $control, $mfrcode);
  /**
   * @param string $messageId
   * @param string $accessToken
   * @param \Prism\PrismToken1\MeterConfigIn $meterConfig
   * @param int $subclass
   * @param double $transferAmount
   * @param int $tokenTime
   * @param int $flags
   * @return \Prism\PrismToken1\Token[]
   * @throws \Prism\PrismToken1\ApiException
   */
  public function issueMseToken($messageId, $accessToken, \Prism\PrismToken1\MeterConfigIn $meterConfig, $subclass, $transferAmount, $tokenTime, $flags);
  /**
   * @param string $messageId
   * @param string $accessToken
   * @param \Prism\PrismToken1\MeterConfigIn $meterConfig
   * @param \Prism\PrismToken1\MeterConfigAmendment $newConfig
   * @return \Prism\PrismToken1\Token[]
   * @throws \Prism\PrismToken1\ApiException
   */
  public function issueKeyChangeTokens($messageId, $accessToken, \Prism\PrismToken1\MeterConfigIn $meterConfig, \Prism\PrismToken1\MeterConfigAmendment $newConfig);
  /**
   * @param string $messageId
   * @param string $accessToken
   * @param \Prism\PrismToken1\MeterConfigIn $meterConfig
   * @param string $tokenDec
   * @return \Prism\PrismToken1\VerifyResult
   * @throws \Prism\PrismToken1\ApiException
   */
  public function verifyToken($messageId, $accessToken, \Prism\PrismToken1\MeterConfigIn $meterConfig, $tokenDec);
  /**
   * @param string $messageId
   * @param string $accessToken
   * @param \Prism\PrismToken1\MeterConfigIn $meterConfig
   * @return \Prism\PrismToken1\Token[]
   * @throws \Prism\PrismToken1\ApiException
   */
  public function issueDitkChangeTokens($messageId, $accessToken, \Prism\PrismToken1\MeterConfigIn $meterConfig);
  /**
   * @param string $messageId
   * @param string $accessToken
   * @param string $reqMessageId
   * @return \Prism\PrismToken1\Token[]
   * @throws \Prism\PrismToken1\ApiException
   */
  public function fetchTokenResult($messageId, $accessToken, $reqMessageId);
  /**
   * @param string $messageId
   * @param string $accessToken
   * @param string $panPattern
   * @return string[]
   * @throws \Prism\PrismToken1\ApiException
   */
  public function ctsResetTidList($messageId, $accessToken, $panPattern);
}

class TokenApiClient implements \Prism\PrismToken1\TokenApiIf {
  protected $input_ = null;
  protected $output_ = null;

  protected $seqid_ = 0;

  public function __construct($input, $output=null) {
    $this->input_ = $input;
    $this->output_ = $output ? $output : $input;
  }

  public function ping($sleepMs, $echo)
  {
    $this->send_ping($sleepMs, $echo);
    return $this->recv_ping();
  }

  public function send_ping($sleepMs, $echo)
  {
    $args = new \Prism\PrismToken1\TokenApi_ping_args();
    $args->sleepMs = $sleepMs;
    $args->echo = $echo;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'ping', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('ping', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_ping()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\Prism\PrismToken1\TokenApi_ping_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \Prism\PrismToken1\TokenApi_ping_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->ex1 !== null) {
      throw $result->ex1;
    }
    throw new \Exception("ping failed: unknown result");
  }

  public function signInWithPassword($messageId, $realm, $username, $password, \Prism\PrismToken1\SessionOptions $sessionOpts)
  {
    $this->send_signInWithPassword($messageId, $realm, $username, $password, $sessionOpts);
    return $this->recv_signInWithPassword();
  }

  public function send_signInWithPassword($messageId, $realm, $username, $password, \Prism\PrismToken1\SessionOptions $sessionOpts)
  {
    $args = new \Prism\PrismToken1\TokenApi_signInWithPassword_args();
    $args->messageId = $messageId;
    $args->realm = $realm;
    $args->username = $username;
    $args->password = $password;
    $args->sessionOpts = $sessionOpts;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'signInWithPassword', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('signInWithPassword', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_signInWithPassword()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\Prism\PrismToken1\TokenApi_signInWithPassword_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \Prism\PrismToken1\TokenApi_signInWithPassword_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->ex1 !== null) {
      throw $result->ex1;
    }
    throw new \Exception("signInWithPassword failed: unknown result");
  }

  public function getStatus($messageId, $accessToken)
  {
    $this->send_getStatus($messageId, $accessToken);
    return $this->recv_getStatus();
  }

  public function send_getStatus($messageId, $accessToken)
  {
    $args = new \Prism\PrismToken1\TokenApi_getStatus_args();
    $args->messageId = $messageId;
    $args->accessToken = $accessToken;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'getStatus', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('getStatus', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_getStatus()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\Prism\PrismToken1\TokenApi_getStatus_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \Prism\PrismToken1\TokenApi_getStatus_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->ex1 !== null) {
      throw $result->ex1;
    }
    throw new \Exception("getStatus failed: unknown result");
  }

  public function parseIdRecord($messageId, $accessToken, $idRecord)
  {
    $this->send_parseIdRecord($messageId, $accessToken, $idRecord);
    return $this->recv_parseIdRecord();
  }

  public function send_parseIdRecord($messageId, $accessToken, $idRecord)
  {
    $args = new \Prism\PrismToken1\TokenApi_parseIdRecord_args();
    $args->messageId = $messageId;
    $args->accessToken = $accessToken;
    $args->idRecord = $idRecord;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'parseIdRecord', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('parseIdRecord', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_parseIdRecord()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\Prism\PrismToken1\TokenApi_parseIdRecord_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \Prism\PrismToken1\TokenApi_parseIdRecord_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->ex1 !== null) {
      throw $result->ex1;
    }
    throw new \Exception("parseIdRecord failed: unknown result");
  }

  public function issueCreditToken($messageId, $accessToken, \Prism\PrismToken1\MeterConfigIn $meterConfig, $subclass, $transferAmount, $tokenTime, $flags)
  {
    $this->send_issueCreditToken($messageId, $accessToken, $meterConfig, $subclass, $transferAmount, $tokenTime, $flags);
    return $this->recv_issueCreditToken();
  }

  public function send_issueCreditToken($messageId, $accessToken, \Prism\PrismToken1\MeterConfigIn $meterConfig, $subclass, $transferAmount, $tokenTime, $flags)
  {
    $args = new \Prism\PrismToken1\TokenApi_issueCreditToken_args();
    $args->messageId = $messageId;
    $args->accessToken = $accessToken;
    $args->meterConfig = $meterConfig;
    $args->subclass = $subclass;
    $args->transferAmount = $transferAmount;
    $args->tokenTime = $tokenTime;
    $args->flags = $flags;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'issueCreditToken', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('issueCreditToken', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_issueCreditToken()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\Prism\PrismToken1\TokenApi_issueCreditToken_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \Prism\PrismToken1\TokenApi_issueCreditToken_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->ex1 !== null) {
      throw $result->ex1;
    }
    throw new \Exception("issueCreditToken failed: unknown result");
  }

  public function issueMeterTestToken($messageId, $accessToken, $subclass, $control, $mfrcode)
  {
    $this->send_issueMeterTestToken($messageId, $accessToken, $subclass, $control, $mfrcode);
    return $this->recv_issueMeterTestToken();
  }

  public function send_issueMeterTestToken($messageId, $accessToken, $subclass, $control, $mfrcode)
  {
    $args = new \Prism\PrismToken1\TokenApi_issueMeterTestToken_args();
    $args->messageId = $messageId;
    $args->accessToken = $accessToken;
    $args->subclass = $subclass;
    $args->control = $control;
    $args->mfrcode = $mfrcode;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'issueMeterTestToken', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('issueMeterTestToken', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_issueMeterTestToken()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\Prism\PrismToken1\TokenApi_issueMeterTestToken_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \Prism\PrismToken1\TokenApi_issueMeterTestToken_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->ex1 !== null) {
      throw $result->ex1;
    }
    throw new \Exception("issueMeterTestToken failed: unknown result");
  }

  public function issueMseToken($messageId, $accessToken, \Prism\PrismToken1\MeterConfigIn $meterConfig, $subclass, $transferAmount, $tokenTime, $flags)
  {
    $this->send_issueMseToken($messageId, $accessToken, $meterConfig, $subclass, $transferAmount, $tokenTime, $flags);
    return $this->recv_issueMseToken();
  }

  public function send_issueMseToken($messageId, $accessToken, \Prism\PrismToken1\MeterConfigIn $meterConfig, $subclass, $transferAmount, $tokenTime, $flags)
  {
    $args = new \Prism\PrismToken1\TokenApi_issueMseToken_args();
    $args->messageId = $messageId;
    $args->accessToken = $accessToken;
    $args->meterConfig = $meterConfig;
    $args->subclass = $subclass;
    $args->transferAmount = $transferAmount;
    $args->tokenTime = $tokenTime;
    $args->flags = $flags;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'issueMseToken', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('issueMseToken', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_issueMseToken()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\Prism\PrismToken1\TokenApi_issueMseToken_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \Prism\PrismToken1\TokenApi_issueMseToken_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->ex1 !== null) {
      throw $result->ex1;
    }
    throw new \Exception("issueMseToken failed: unknown result");
  }

  public function issueKeyChangeTokens($messageId, $accessToken, \Prism\PrismToken1\MeterConfigIn $meterConfig, \Prism\PrismToken1\MeterConfigAmendment $newConfig)
  {
    $this->send_issueKeyChangeTokens($messageId, $accessToken, $meterConfig, $newConfig);
    return $this->recv_issueKeyChangeTokens();
  }

  public function send_issueKeyChangeTokens($messageId, $accessToken, \Prism\PrismToken1\MeterConfigIn $meterConfig, \Prism\PrismToken1\MeterConfigAmendment $newConfig)
  {
    $args = new \Prism\PrismToken1\TokenApi_issueKeyChangeTokens_args();
    $args->messageId = $messageId;
    $args->accessToken = $accessToken;
    $args->meterConfig = $meterConfig;
    $args->newConfig = $newConfig;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'issueKeyChangeTokens', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('issueKeyChangeTokens', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_issueKeyChangeTokens()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\Prism\PrismToken1\TokenApi_issueKeyChangeTokens_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \Prism\PrismToken1\TokenApi_issueKeyChangeTokens_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->ex1 !== null) {
      throw $result->ex1;
    }
    throw new \Exception("issueKeyChangeTokens failed: unknown result");
  }

  public function verifyToken($messageId, $accessToken, \Prism\PrismToken1\MeterConfigIn $meterConfig, $tokenDec)
  {
    $this->send_verifyToken($messageId, $accessToken, $meterConfig, $tokenDec);
    return $this->recv_verifyToken();
  }

  public function send_verifyToken($messageId, $accessToken, \Prism\PrismToken1\MeterConfigIn $meterConfig, $tokenDec)
  {
    $args = new \Prism\PrismToken1\TokenApi_verifyToken_args();
    $args->messageId = $messageId;
    $args->accessToken = $accessToken;
    $args->meterConfig = $meterConfig;
    $args->tokenDec = $tokenDec;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'verifyToken', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('verifyToken', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_verifyToken()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\Prism\PrismToken1\TokenApi_verifyToken_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \Prism\PrismToken1\TokenApi_verifyToken_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->ex1 !== null) {
      throw $result->ex1;
    }
    throw new \Exception("verifyToken failed: unknown result");
  }

  public function issueDitkChangeTokens($messageId, $accessToken, \Prism\PrismToken1\MeterConfigIn $meterConfig)
  {
    $this->send_issueDitkChangeTokens($messageId, $accessToken, $meterConfig);
    return $this->recv_issueDitkChangeTokens();
  }

  public function send_issueDitkChangeTokens($messageId, $accessToken, \Prism\PrismToken1\MeterConfigIn $meterConfig)
  {
    $args = new \Prism\PrismToken1\TokenApi_issueDitkChangeTokens_args();
    $args->messageId = $messageId;
    $args->accessToken = $accessToken;
    $args->meterConfig = $meterConfig;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'issueDitkChangeTokens', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('issueDitkChangeTokens', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_issueDitkChangeTokens()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\Prism\PrismToken1\TokenApi_issueDitkChangeTokens_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \Prism\PrismToken1\TokenApi_issueDitkChangeTokens_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->ex1 !== null) {
      throw $result->ex1;
    }
    throw new \Exception("issueDitkChangeTokens failed: unknown result");
  }

  public function fetchTokenResult($messageId, $accessToken, $reqMessageId)
  {
    $this->send_fetchTokenResult($messageId, $accessToken, $reqMessageId);
    return $this->recv_fetchTokenResult();
  }

  public function send_fetchTokenResult($messageId, $accessToken, $reqMessageId)
  {
    $args = new \Prism\PrismToken1\TokenApi_fetchTokenResult_args();
    $args->messageId = $messageId;
    $args->accessToken = $accessToken;
    $args->reqMessageId = $reqMessageId;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'fetchTokenResult', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('fetchTokenResult', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_fetchTokenResult()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\Prism\PrismToken1\TokenApi_fetchTokenResult_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \Prism\PrismToken1\TokenApi_fetchTokenResult_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->ex1 !== null) {
      throw $result->ex1;
    }
    throw new \Exception("fetchTokenResult failed: unknown result");
  }

  public function ctsResetTidList($messageId, $accessToken, $panPattern)
  {
    $this->send_ctsResetTidList($messageId, $accessToken, $panPattern);
    return $this->recv_ctsResetTidList();
  }

  public function send_ctsResetTidList($messageId, $accessToken, $panPattern)
  {
    $args = new \Prism\PrismToken1\TokenApi_ctsResetTidList_args();
    $args->messageId = $messageId;
    $args->accessToken = $accessToken;
    $args->panPattern = $panPattern;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'ctsResetTidList', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('ctsResetTidList', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_ctsResetTidList()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\Prism\PrismToken1\TokenApi_ctsResetTidList_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \Prism\PrismToken1\TokenApi_ctsResetTidList_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->ex1 !== null) {
      throw $result->ex1;
    }
    throw new \Exception("ctsResetTidList failed: unknown result");
  }

}

// HELPER FUNCTIONS AND STRUCTURES

class TokenApi_ping_args {
  static $_TSPEC;

  /**
   * @var int
   */
  public $sleepMs = null;
  /**
   * @var string
   */
  public $echo = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'sleepMs',
          'type' => TType::I32,
          ),
        2 => array(
          'var' => 'echo',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['sleepMs'])) {
        $this->sleepMs = $vals['sleepMs'];
      }
      if (isset($vals['echo'])) {
        $this->echo = $vals['echo'];
      }
    }
  }

  public function getName() {
    return 'TokenApi_ping_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->sleepMs);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->echo);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TokenApi_ping_args');
    if ($this->sleepMs !== null) {
      $xfer += $output->writeFieldBegin('sleepMs', TType::I32, 1);
      $xfer += $output->writeI32($this->sleepMs);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->echo !== null) {
      $xfer += $output->writeFieldBegin('echo', TType::STRING, 2);
      $xfer += $output->writeString($this->echo);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TokenApi_ping_result {
  static $_TSPEC;

  /**
   * @var string
   */
  public $success = null;
  /**
   * @var \Prism\PrismToken1\ApiException
   */
  public $ex1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRING,
          ),
        1 => array(
          'var' => 'ex1',
          'type' => TType::STRUCT,
          'class' => '\Prism\PrismToken1\ApiException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['ex1'])) {
        $this->ex1 = $vals['ex1'];
      }
    }
  }

  public function getName() {
    return 'TokenApi_ping_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->ex1 = new \Prism\PrismToken1\ApiException();
            $xfer += $this->ex1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TokenApi_ping_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
      $xfer += $output->writeString($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->ex1 !== null) {
      $xfer += $output->writeFieldBegin('ex1', TType::STRUCT, 1);
      $xfer += $this->ex1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TokenApi_signInWithPassword_args {
  static $_TSPEC;

  /**
   * @var string
   */
  public $messageId = null;
  /**
   * @var string
   */
  public $realm = null;
  /**
   * @var string
   */
  public $username = null;
  /**
   * @var string
   */
  public $password = null;
  /**
   * @var \Prism\PrismToken1\SessionOptions
   */
  public $sessionOpts = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'messageId',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'realm',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'username',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'password',
          'type' => TType::STRING,
          ),
        5 => array(
          'var' => 'sessionOpts',
          'type' => TType::STRUCT,
          'class' => '\Prism\PrismToken1\SessionOptions',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['messageId'])) {
        $this->messageId = $vals['messageId'];
      }
      if (isset($vals['realm'])) {
        $this->realm = $vals['realm'];
      }
      if (isset($vals['username'])) {
        $this->username = $vals['username'];
      }
      if (isset($vals['password'])) {
        $this->password = $vals['password'];
      }
      if (isset($vals['sessionOpts'])) {
        $this->sessionOpts = $vals['sessionOpts'];
      }
    }
  }

  public function getName() {
    return 'TokenApi_signInWithPassword_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->messageId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->realm);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->username);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->password);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRUCT) {
            $this->sessionOpts = new \Prism\PrismToken1\SessionOptions();
            $xfer += $this->sessionOpts->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TokenApi_signInWithPassword_args');
    if ($this->messageId !== null) {
      $xfer += $output->writeFieldBegin('messageId', TType::STRING, 1);
      $xfer += $output->writeString($this->messageId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->realm !== null) {
      $xfer += $output->writeFieldBegin('realm', TType::STRING, 2);
      $xfer += $output->writeString($this->realm);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->username !== null) {
      $xfer += $output->writeFieldBegin('username', TType::STRING, 3);
      $xfer += $output->writeString($this->username);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->password !== null) {
      $xfer += $output->writeFieldBegin('password', TType::STRING, 4);
      $xfer += $output->writeString($this->password);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->sessionOpts !== null) {
      if (!is_object($this->sessionOpts)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('sessionOpts', TType::STRUCT, 5);
      $xfer += $this->sessionOpts->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TokenApi_signInWithPassword_result {
  static $_TSPEC;

  /**
   * @var \Prism\PrismToken1\SignInResult
   */
  public $success = null;
  /**
   * @var \Prism\PrismToken1\ApiException
   */
  public $ex1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\Prism\PrismToken1\SignInResult',
          ),
        1 => array(
          'var' => 'ex1',
          'type' => TType::STRUCT,
          'class' => '\Prism\PrismToken1\ApiException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['ex1'])) {
        $this->ex1 = $vals['ex1'];
      }
    }
  }

  public function getName() {
    return 'TokenApi_signInWithPassword_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \Prism\PrismToken1\SignInResult();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->ex1 = new \Prism\PrismToken1\ApiException();
            $xfer += $this->ex1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TokenApi_signInWithPassword_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->ex1 !== null) {
      $xfer += $output->writeFieldBegin('ex1', TType::STRUCT, 1);
      $xfer += $this->ex1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TokenApi_getStatus_args {
  static $_TSPEC;

  /**
   * @var string
   */
  public $messageId = null;
  /**
   * @var string
   */
  public $accessToken = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'messageId',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'accessToken',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['messageId'])) {
        $this->messageId = $vals['messageId'];
      }
      if (isset($vals['accessToken'])) {
        $this->accessToken = $vals['accessToken'];
      }
    }
  }

  public function getName() {
    return 'TokenApi_getStatus_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->messageId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->accessToken);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TokenApi_getStatus_args');
    if ($this->messageId !== null) {
      $xfer += $output->writeFieldBegin('messageId', TType::STRING, 1);
      $xfer += $output->writeString($this->messageId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->accessToken !== null) {
      $xfer += $output->writeFieldBegin('accessToken', TType::STRING, 2);
      $xfer += $output->writeString($this->accessToken);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TokenApi_getStatus_result {
  static $_TSPEC;

  /**
   * @var \Prism\PrismToken1\NodeStatus[]
   */
  public $success = null;
  /**
   * @var \Prism\PrismToken1\ApiException
   */
  public $ex1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\Prism\PrismToken1\NodeStatus',
            ),
          ),
        1 => array(
          'var' => 'ex1',
          'type' => TType::STRUCT,
          'class' => '\Prism\PrismToken1\ApiException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['ex1'])) {
        $this->ex1 = $vals['ex1'];
      }
    }
  }

  public function getName() {
    return 'TokenApi_getStatus_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size16 = 0;
            $_etype19 = 0;
            $xfer += $input->readListBegin($_etype19, $_size16);
            for ($_i20 = 0; $_i20 < $_size16; ++$_i20)
            {
              $elem21 = null;
              $elem21 = new \Prism\PrismToken1\NodeStatus();
              $xfer += $elem21->read($input);
              $this->success []= $elem21;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->ex1 = new \Prism\PrismToken1\ApiException();
            $xfer += $this->ex1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TokenApi_getStatus_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter22)
          {
            $xfer += $iter22->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->ex1 !== null) {
      $xfer += $output->writeFieldBegin('ex1', TType::STRUCT, 1);
      $xfer += $this->ex1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TokenApi_parseIdRecord_args {
  static $_TSPEC;

  /**
   * @var string
   */
  public $messageId = null;
  /**
   * @var string
   */
  public $accessToken = null;
  /**
   * @var string
   */
  public $idRecord = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'messageId',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'accessToken',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'idRecord',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['messageId'])) {
        $this->messageId = $vals['messageId'];
      }
      if (isset($vals['accessToken'])) {
        $this->accessToken = $vals['accessToken'];
      }
      if (isset($vals['idRecord'])) {
        $this->idRecord = $vals['idRecord'];
      }
    }
  }

  public function getName() {
    return 'TokenApi_parseIdRecord_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->messageId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->accessToken);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->idRecord);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TokenApi_parseIdRecord_args');
    if ($this->messageId !== null) {
      $xfer += $output->writeFieldBegin('messageId', TType::STRING, 1);
      $xfer += $output->writeString($this->messageId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->accessToken !== null) {
      $xfer += $output->writeFieldBegin('accessToken', TType::STRING, 2);
      $xfer += $output->writeString($this->accessToken);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->idRecord !== null) {
      $xfer += $output->writeFieldBegin('idRecord', TType::STRING, 3);
      $xfer += $output->writeString($this->idRecord);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TokenApi_parseIdRecord_result {
  static $_TSPEC;

  /**
   * @var \Prism\PrismToken1\MeterConfigIn
   */
  public $success = null;
  /**
   * @var \Prism\PrismToken1\ApiException
   */
  public $ex1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\Prism\PrismToken1\MeterConfigIn',
          ),
        1 => array(
          'var' => 'ex1',
          'type' => TType::STRUCT,
          'class' => '\Prism\PrismToken1\ApiException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['ex1'])) {
        $this->ex1 = $vals['ex1'];
      }
    }
  }

  public function getName() {
    return 'TokenApi_parseIdRecord_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \Prism\PrismToken1\MeterConfigIn();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->ex1 = new \Prism\PrismToken1\ApiException();
            $xfer += $this->ex1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TokenApi_parseIdRecord_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->ex1 !== null) {
      $xfer += $output->writeFieldBegin('ex1', TType::STRUCT, 1);
      $xfer += $this->ex1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TokenApi_issueCreditToken_args {
  static $_TSPEC;

  /**
   * @var string
   */
  public $messageId = null;
  /**
   * @var string
   */
  public $accessToken = null;
  /**
   * @var \Prism\PrismToken1\MeterConfigIn
   */
  public $meterConfig = null;
  /**
   * @var int
   */
  public $subclass = null;
  /**
   * @var double
   */
  public $transferAmount = null;
  /**
   * @var int
   */
  public $tokenTime = null;
  /**
   * @var int
   */
  public $flags = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'messageId',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'accessToken',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'meterConfig',
          'type' => TType::STRUCT,
          'class' => '\Prism\PrismToken1\MeterConfigIn',
          ),
        4 => array(
          'var' => 'subclass',
          'type' => TType::I16,
          ),
        5 => array(
          'var' => 'transferAmount',
          'type' => TType::DOUBLE,
          ),
        6 => array(
          'var' => 'tokenTime',
          'type' => TType::I64,
          ),
        7 => array(
          'var' => 'flags',
          'type' => TType::I64,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['messageId'])) {
        $this->messageId = $vals['messageId'];
      }
      if (isset($vals['accessToken'])) {
        $this->accessToken = $vals['accessToken'];
      }
      if (isset($vals['meterConfig'])) {
        $this->meterConfig = $vals['meterConfig'];
      }
      if (isset($vals['subclass'])) {
        $this->subclass = $vals['subclass'];
      }
      if (isset($vals['transferAmount'])) {
        $this->transferAmount = $vals['transferAmount'];
      }
      if (isset($vals['tokenTime'])) {
        $this->tokenTime = $vals['tokenTime'];
      }
      if (isset($vals['flags'])) {
        $this->flags = $vals['flags'];
      }
    }
  }

  public function getName() {
    return 'TokenApi_issueCreditToken_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->messageId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->accessToken);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->meterConfig = new \Prism\PrismToken1\MeterConfigIn();
            $xfer += $this->meterConfig->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I16) {
            $xfer += $input->readI16($this->subclass);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::DOUBLE) {
            $xfer += $input->readDouble($this->transferAmount);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->tokenTime);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->flags);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TokenApi_issueCreditToken_args');
    if ($this->messageId !== null) {
      $xfer += $output->writeFieldBegin('messageId', TType::STRING, 1);
      $xfer += $output->writeString($this->messageId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->accessToken !== null) {
      $xfer += $output->writeFieldBegin('accessToken', TType::STRING, 2);
      $xfer += $output->writeString($this->accessToken);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->meterConfig !== null) {
      if (!is_object($this->meterConfig)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('meterConfig', TType::STRUCT, 3);
      $xfer += $this->meterConfig->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->subclass !== null) {
      $xfer += $output->writeFieldBegin('subclass', TType::I16, 4);
      $xfer += $output->writeI16($this->subclass);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->transferAmount !== null) {
      $xfer += $output->writeFieldBegin('transferAmount', TType::DOUBLE, 5);
      $xfer += $output->writeDouble($this->transferAmount);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tokenTime !== null) {
      $xfer += $output->writeFieldBegin('tokenTime', TType::I64, 6);
      $xfer += $output->writeI64($this->tokenTime);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->flags !== null) {
      $xfer += $output->writeFieldBegin('flags', TType::I64, 7);
      $xfer += $output->writeI64($this->flags);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TokenApi_issueCreditToken_result {
  static $_TSPEC;

  /**
   * @var \Prism\PrismToken1\Token[]
   */
  public $success = null;
  /**
   * @var \Prism\PrismToken1\ApiException
   */
  public $ex1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\Prism\PrismToken1\Token',
            ),
          ),
        1 => array(
          'var' => 'ex1',
          'type' => TType::STRUCT,
          'class' => '\Prism\PrismToken1\ApiException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['ex1'])) {
        $this->ex1 = $vals['ex1'];
      }
    }
  }

  public function getName() {
    return 'TokenApi_issueCreditToken_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size23 = 0;
            $_etype26 = 0;
            $xfer += $input->readListBegin($_etype26, $_size23);
            for ($_i27 = 0; $_i27 < $_size23; ++$_i27)
            {
              $elem28 = null;
              $elem28 = new \Prism\PrismToken1\Token();
              $xfer += $elem28->read($input);
              $this->success []= $elem28;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->ex1 = new \Prism\PrismToken1\ApiException();
            $xfer += $this->ex1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TokenApi_issueCreditToken_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter29)
          {
            $xfer += $iter29->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->ex1 !== null) {
      $xfer += $output->writeFieldBegin('ex1', TType::STRUCT, 1);
      $xfer += $this->ex1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TokenApi_issueMeterTestToken_args {
  static $_TSPEC;

  /**
   * @var string
   */
  public $messageId = null;
  /**
   * @var string
   */
  public $accessToken = null;
  /**
   * @var int
   */
  public $subclass = null;
  /**
   * @var int
   */
  public $control = null;
  /**
   * @var int
   */
  public $mfrcode = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'messageId',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'accessToken',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'subclass',
          'type' => TType::I16,
          ),
        4 => array(
          'var' => 'control',
          'type' => TType::I64,
          ),
        5 => array(
          'var' => 'mfrcode',
          'type' => TType::I16,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['messageId'])) {
        $this->messageId = $vals['messageId'];
      }
      if (isset($vals['accessToken'])) {
        $this->accessToken = $vals['accessToken'];
      }
      if (isset($vals['subclass'])) {
        $this->subclass = $vals['subclass'];
      }
      if (isset($vals['control'])) {
        $this->control = $vals['control'];
      }
      if (isset($vals['mfrcode'])) {
        $this->mfrcode = $vals['mfrcode'];
      }
    }
  }

  public function getName() {
    return 'TokenApi_issueMeterTestToken_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->messageId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->accessToken);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I16) {
            $xfer += $input->readI16($this->subclass);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->control);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::I16) {
            $xfer += $input->readI16($this->mfrcode);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TokenApi_issueMeterTestToken_args');
    if ($this->messageId !== null) {
      $xfer += $output->writeFieldBegin('messageId', TType::STRING, 1);
      $xfer += $output->writeString($this->messageId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->accessToken !== null) {
      $xfer += $output->writeFieldBegin('accessToken', TType::STRING, 2);
      $xfer += $output->writeString($this->accessToken);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->subclass !== null) {
      $xfer += $output->writeFieldBegin('subclass', TType::I16, 3);
      $xfer += $output->writeI16($this->subclass);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->control !== null) {
      $xfer += $output->writeFieldBegin('control', TType::I64, 4);
      $xfer += $output->writeI64($this->control);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->mfrcode !== null) {
      $xfer += $output->writeFieldBegin('mfrcode', TType::I16, 5);
      $xfer += $output->writeI16($this->mfrcode);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TokenApi_issueMeterTestToken_result {
  static $_TSPEC;

  /**
   * @var \Prism\PrismToken1\MeterTestToken
   */
  public $success = null;
  /**
   * @var \Prism\PrismToken1\ApiException
   */
  public $ex1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\Prism\PrismToken1\MeterTestToken',
          ),
        1 => array(
          'var' => 'ex1',
          'type' => TType::STRUCT,
          'class' => '\Prism\PrismToken1\ApiException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['ex1'])) {
        $this->ex1 = $vals['ex1'];
      }
    }
  }

  public function getName() {
    return 'TokenApi_issueMeterTestToken_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \Prism\PrismToken1\MeterTestToken();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->ex1 = new \Prism\PrismToken1\ApiException();
            $xfer += $this->ex1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TokenApi_issueMeterTestToken_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->ex1 !== null) {
      $xfer += $output->writeFieldBegin('ex1', TType::STRUCT, 1);
      $xfer += $this->ex1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TokenApi_issueMseToken_args {
  static $_TSPEC;

  /**
   * @var string
   */
  public $messageId = null;
  /**
   * @var string
   */
  public $accessToken = null;
  /**
   * @var \Prism\PrismToken1\MeterConfigIn
   */
  public $meterConfig = null;
  /**
   * @var int
   */
  public $subclass = null;
  /**
   * @var double
   */
  public $transferAmount = null;
  /**
   * @var int
   */
  public $tokenTime = null;
  /**
   * @var int
   */
  public $flags = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'messageId',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'accessToken',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'meterConfig',
          'type' => TType::STRUCT,
          'class' => '\Prism\PrismToken1\MeterConfigIn',
          ),
        4 => array(
          'var' => 'subclass',
          'type' => TType::I16,
          ),
        5 => array(
          'var' => 'transferAmount',
          'type' => TType::DOUBLE,
          ),
        6 => array(
          'var' => 'tokenTime',
          'type' => TType::I64,
          ),
        7 => array(
          'var' => 'flags',
          'type' => TType::I64,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['messageId'])) {
        $this->messageId = $vals['messageId'];
      }
      if (isset($vals['accessToken'])) {
        $this->accessToken = $vals['accessToken'];
      }
      if (isset($vals['meterConfig'])) {
        $this->meterConfig = $vals['meterConfig'];
      }
      if (isset($vals['subclass'])) {
        $this->subclass = $vals['subclass'];
      }
      if (isset($vals['transferAmount'])) {
        $this->transferAmount = $vals['transferAmount'];
      }
      if (isset($vals['tokenTime'])) {
        $this->tokenTime = $vals['tokenTime'];
      }
      if (isset($vals['flags'])) {
        $this->flags = $vals['flags'];
      }
    }
  }

  public function getName() {
    return 'TokenApi_issueMseToken_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->messageId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->accessToken);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->meterConfig = new \Prism\PrismToken1\MeterConfigIn();
            $xfer += $this->meterConfig->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I16) {
            $xfer += $input->readI16($this->subclass);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::DOUBLE) {
            $xfer += $input->readDouble($this->transferAmount);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->tokenTime);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->flags);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TokenApi_issueMseToken_args');
    if ($this->messageId !== null) {
      $xfer += $output->writeFieldBegin('messageId', TType::STRING, 1);
      $xfer += $output->writeString($this->messageId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->accessToken !== null) {
      $xfer += $output->writeFieldBegin('accessToken', TType::STRING, 2);
      $xfer += $output->writeString($this->accessToken);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->meterConfig !== null) {
      if (!is_object($this->meterConfig)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('meterConfig', TType::STRUCT, 3);
      $xfer += $this->meterConfig->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->subclass !== null) {
      $xfer += $output->writeFieldBegin('subclass', TType::I16, 4);
      $xfer += $output->writeI16($this->subclass);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->transferAmount !== null) {
      $xfer += $output->writeFieldBegin('transferAmount', TType::DOUBLE, 5);
      $xfer += $output->writeDouble($this->transferAmount);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tokenTime !== null) {
      $xfer += $output->writeFieldBegin('tokenTime', TType::I64, 6);
      $xfer += $output->writeI64($this->tokenTime);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->flags !== null) {
      $xfer += $output->writeFieldBegin('flags', TType::I64, 7);
      $xfer += $output->writeI64($this->flags);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TokenApi_issueMseToken_result {
  static $_TSPEC;

  /**
   * @var \Prism\PrismToken1\Token[]
   */
  public $success = null;
  /**
   * @var \Prism\PrismToken1\ApiException
   */
  public $ex1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\Prism\PrismToken1\Token',
            ),
          ),
        1 => array(
          'var' => 'ex1',
          'type' => TType::STRUCT,
          'class' => '\Prism\PrismToken1\ApiException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['ex1'])) {
        $this->ex1 = $vals['ex1'];
      }
    }
  }

  public function getName() {
    return 'TokenApi_issueMseToken_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size30 = 0;
            $_etype33 = 0;
            $xfer += $input->readListBegin($_etype33, $_size30);
            for ($_i34 = 0; $_i34 < $_size30; ++$_i34)
            {
              $elem35 = null;
              $elem35 = new \Prism\PrismToken1\Token();
              $xfer += $elem35->read($input);
              $this->success []= $elem35;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->ex1 = new \Prism\PrismToken1\ApiException();
            $xfer += $this->ex1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TokenApi_issueMseToken_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter36)
          {
            $xfer += $iter36->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->ex1 !== null) {
      $xfer += $output->writeFieldBegin('ex1', TType::STRUCT, 1);
      $xfer += $this->ex1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TokenApi_issueKeyChangeTokens_args {
  static $_TSPEC;

  /**
   * @var string
   */
  public $messageId = null;
  /**
   * @var string
   */
  public $accessToken = null;
  /**
   * @var \Prism\PrismToken1\MeterConfigIn
   */
  public $meterConfig = null;
  /**
   * @var \Prism\PrismToken1\MeterConfigAmendment
   */
  public $newConfig = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'messageId',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'accessToken',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'meterConfig',
          'type' => TType::STRUCT,
          'class' => '\Prism\PrismToken1\MeterConfigIn',
          ),
        4 => array(
          'var' => 'newConfig',
          'type' => TType::STRUCT,
          'class' => '\Prism\PrismToken1\MeterConfigAmendment',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['messageId'])) {
        $this->messageId = $vals['messageId'];
      }
      if (isset($vals['accessToken'])) {
        $this->accessToken = $vals['accessToken'];
      }
      if (isset($vals['meterConfig'])) {
        $this->meterConfig = $vals['meterConfig'];
      }
      if (isset($vals['newConfig'])) {
        $this->newConfig = $vals['newConfig'];
      }
    }
  }

  public function getName() {
    return 'TokenApi_issueKeyChangeTokens_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->messageId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->accessToken);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->meterConfig = new \Prism\PrismToken1\MeterConfigIn();
            $xfer += $this->meterConfig->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRUCT) {
            $this->newConfig = new \Prism\PrismToken1\MeterConfigAmendment();
            $xfer += $this->newConfig->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TokenApi_issueKeyChangeTokens_args');
    if ($this->messageId !== null) {
      $xfer += $output->writeFieldBegin('messageId', TType::STRING, 1);
      $xfer += $output->writeString($this->messageId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->accessToken !== null) {
      $xfer += $output->writeFieldBegin('accessToken', TType::STRING, 2);
      $xfer += $output->writeString($this->accessToken);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->meterConfig !== null) {
      if (!is_object($this->meterConfig)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('meterConfig', TType::STRUCT, 3);
      $xfer += $this->meterConfig->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->newConfig !== null) {
      if (!is_object($this->newConfig)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('newConfig', TType::STRUCT, 4);
      $xfer += $this->newConfig->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TokenApi_issueKeyChangeTokens_result {
  static $_TSPEC;

  /**
   * @var \Prism\PrismToken1\Token[]
   */
  public $success = null;
  /**
   * @var \Prism\PrismToken1\ApiException
   */
  public $ex1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\Prism\PrismToken1\Token',
            ),
          ),
        1 => array(
          'var' => 'ex1',
          'type' => TType::STRUCT,
          'class' => '\Prism\PrismToken1\ApiException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['ex1'])) {
        $this->ex1 = $vals['ex1'];
      }
    }
  }

  public function getName() {
    return 'TokenApi_issueKeyChangeTokens_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size37 = 0;
            $_etype40 = 0;
            $xfer += $input->readListBegin($_etype40, $_size37);
            for ($_i41 = 0; $_i41 < $_size37; ++$_i41)
            {
              $elem42 = null;
              $elem42 = new \Prism\PrismToken1\Token();
              $xfer += $elem42->read($input);
              $this->success []= $elem42;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->ex1 = new \Prism\PrismToken1\ApiException();
            $xfer += $this->ex1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TokenApi_issueKeyChangeTokens_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter43)
          {
            $xfer += $iter43->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->ex1 !== null) {
      $xfer += $output->writeFieldBegin('ex1', TType::STRUCT, 1);
      $xfer += $this->ex1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TokenApi_verifyToken_args {
  static $_TSPEC;

  /**
   * @var string
   */
  public $messageId = null;
  /**
   * @var string
   */
  public $accessToken = null;
  /**
   * @var \Prism\PrismToken1\MeterConfigIn
   */
  public $meterConfig = null;
  /**
   * @var string
   */
  public $tokenDec = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'messageId',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'accessToken',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'meterConfig',
          'type' => TType::STRUCT,
          'class' => '\Prism\PrismToken1\MeterConfigIn',
          ),
        4 => array(
          'var' => 'tokenDec',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['messageId'])) {
        $this->messageId = $vals['messageId'];
      }
      if (isset($vals['accessToken'])) {
        $this->accessToken = $vals['accessToken'];
      }
      if (isset($vals['meterConfig'])) {
        $this->meterConfig = $vals['meterConfig'];
      }
      if (isset($vals['tokenDec'])) {
        $this->tokenDec = $vals['tokenDec'];
      }
    }
  }

  public function getName() {
    return 'TokenApi_verifyToken_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->messageId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->accessToken);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->meterConfig = new \Prism\PrismToken1\MeterConfigIn();
            $xfer += $this->meterConfig->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tokenDec);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TokenApi_verifyToken_args');
    if ($this->messageId !== null) {
      $xfer += $output->writeFieldBegin('messageId', TType::STRING, 1);
      $xfer += $output->writeString($this->messageId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->accessToken !== null) {
      $xfer += $output->writeFieldBegin('accessToken', TType::STRING, 2);
      $xfer += $output->writeString($this->accessToken);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->meterConfig !== null) {
      if (!is_object($this->meterConfig)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('meterConfig', TType::STRUCT, 3);
      $xfer += $this->meterConfig->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tokenDec !== null) {
      $xfer += $output->writeFieldBegin('tokenDec', TType::STRING, 4);
      $xfer += $output->writeString($this->tokenDec);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TokenApi_verifyToken_result {
  static $_TSPEC;

  /**
   * @var \Prism\PrismToken1\VerifyResult
   */
  public $success = null;
  /**
   * @var \Prism\PrismToken1\ApiException
   */
  public $ex1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\Prism\PrismToken1\VerifyResult',
          ),
        1 => array(
          'var' => 'ex1',
          'type' => TType::STRUCT,
          'class' => '\Prism\PrismToken1\ApiException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['ex1'])) {
        $this->ex1 = $vals['ex1'];
      }
    }
  }

  public function getName() {
    return 'TokenApi_verifyToken_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \Prism\PrismToken1\VerifyResult();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->ex1 = new \Prism\PrismToken1\ApiException();
            $xfer += $this->ex1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TokenApi_verifyToken_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->ex1 !== null) {
      $xfer += $output->writeFieldBegin('ex1', TType::STRUCT, 1);
      $xfer += $this->ex1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TokenApi_issueDitkChangeTokens_args {
  static $_TSPEC;

  /**
   * @var string
   */
  public $messageId = null;
  /**
   * @var string
   */
  public $accessToken = null;
  /**
   * @var \Prism\PrismToken1\MeterConfigIn
   */
  public $meterConfig = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'messageId',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'accessToken',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'meterConfig',
          'type' => TType::STRUCT,
          'class' => '\Prism\PrismToken1\MeterConfigIn',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['messageId'])) {
        $this->messageId = $vals['messageId'];
      }
      if (isset($vals['accessToken'])) {
        $this->accessToken = $vals['accessToken'];
      }
      if (isset($vals['meterConfig'])) {
        $this->meterConfig = $vals['meterConfig'];
      }
    }
  }

  public function getName() {
    return 'TokenApi_issueDitkChangeTokens_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->messageId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->accessToken);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->meterConfig = new \Prism\PrismToken1\MeterConfigIn();
            $xfer += $this->meterConfig->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TokenApi_issueDitkChangeTokens_args');
    if ($this->messageId !== null) {
      $xfer += $output->writeFieldBegin('messageId', TType::STRING, 1);
      $xfer += $output->writeString($this->messageId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->accessToken !== null) {
      $xfer += $output->writeFieldBegin('accessToken', TType::STRING, 2);
      $xfer += $output->writeString($this->accessToken);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->meterConfig !== null) {
      if (!is_object($this->meterConfig)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('meterConfig', TType::STRUCT, 3);
      $xfer += $this->meterConfig->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TokenApi_issueDitkChangeTokens_result {
  static $_TSPEC;

  /**
   * @var \Prism\PrismToken1\Token[]
   */
  public $success = null;
  /**
   * @var \Prism\PrismToken1\ApiException
   */
  public $ex1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\Prism\PrismToken1\Token',
            ),
          ),
        1 => array(
          'var' => 'ex1',
          'type' => TType::STRUCT,
          'class' => '\Prism\PrismToken1\ApiException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['ex1'])) {
        $this->ex1 = $vals['ex1'];
      }
    }
  }

  public function getName() {
    return 'TokenApi_issueDitkChangeTokens_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size44 = 0;
            $_etype47 = 0;
            $xfer += $input->readListBegin($_etype47, $_size44);
            for ($_i48 = 0; $_i48 < $_size44; ++$_i48)
            {
              $elem49 = null;
              $elem49 = new \Prism\PrismToken1\Token();
              $xfer += $elem49->read($input);
              $this->success []= $elem49;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->ex1 = new \Prism\PrismToken1\ApiException();
            $xfer += $this->ex1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TokenApi_issueDitkChangeTokens_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter50)
          {
            $xfer += $iter50->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->ex1 !== null) {
      $xfer += $output->writeFieldBegin('ex1', TType::STRUCT, 1);
      $xfer += $this->ex1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TokenApi_fetchTokenResult_args {
  static $_TSPEC;

  /**
   * @var string
   */
  public $messageId = null;
  /**
   * @var string
   */
  public $accessToken = null;
  /**
   * @var string
   */
  public $reqMessageId = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'messageId',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'accessToken',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'reqMessageId',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['messageId'])) {
        $this->messageId = $vals['messageId'];
      }
      if (isset($vals['accessToken'])) {
        $this->accessToken = $vals['accessToken'];
      }
      if (isset($vals['reqMessageId'])) {
        $this->reqMessageId = $vals['reqMessageId'];
      }
    }
  }

  public function getName() {
    return 'TokenApi_fetchTokenResult_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->messageId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->accessToken);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->reqMessageId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TokenApi_fetchTokenResult_args');
    if ($this->messageId !== null) {
      $xfer += $output->writeFieldBegin('messageId', TType::STRING, 1);
      $xfer += $output->writeString($this->messageId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->accessToken !== null) {
      $xfer += $output->writeFieldBegin('accessToken', TType::STRING, 2);
      $xfer += $output->writeString($this->accessToken);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->reqMessageId !== null) {
      $xfer += $output->writeFieldBegin('reqMessageId', TType::STRING, 3);
      $xfer += $output->writeString($this->reqMessageId);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TokenApi_fetchTokenResult_result {
  static $_TSPEC;

  /**
   * @var \Prism\PrismToken1\Token[]
   */
  public $success = null;
  /**
   * @var \Prism\PrismToken1\ApiException
   */
  public $ex1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\Prism\PrismToken1\Token',
            ),
          ),
        1 => array(
          'var' => 'ex1',
          'type' => TType::STRUCT,
          'class' => '\Prism\PrismToken1\ApiException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['ex1'])) {
        $this->ex1 = $vals['ex1'];
      }
    }
  }

  public function getName() {
    return 'TokenApi_fetchTokenResult_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size51 = 0;
            $_etype54 = 0;
            $xfer += $input->readListBegin($_etype54, $_size51);
            for ($_i55 = 0; $_i55 < $_size51; ++$_i55)
            {
              $elem56 = null;
              $elem56 = new \Prism\PrismToken1\Token();
              $xfer += $elem56->read($input);
              $this->success []= $elem56;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->ex1 = new \Prism\PrismToken1\ApiException();
            $xfer += $this->ex1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TokenApi_fetchTokenResult_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter57)
          {
            $xfer += $iter57->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->ex1 !== null) {
      $xfer += $output->writeFieldBegin('ex1', TType::STRUCT, 1);
      $xfer += $this->ex1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TokenApi_ctsResetTidList_args {
  static $_TSPEC;

  /**
   * @var string
   */
  public $messageId = null;
  /**
   * @var string
   */
  public $accessToken = null;
  /**
   * @var string
   */
  public $panPattern = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'messageId',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'accessToken',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'panPattern',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['messageId'])) {
        $this->messageId = $vals['messageId'];
      }
      if (isset($vals['accessToken'])) {
        $this->accessToken = $vals['accessToken'];
      }
      if (isset($vals['panPattern'])) {
        $this->panPattern = $vals['panPattern'];
      }
    }
  }

  public function getName() {
    return 'TokenApi_ctsResetTidList_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->messageId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->accessToken);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->panPattern);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TokenApi_ctsResetTidList_args');
    if ($this->messageId !== null) {
      $xfer += $output->writeFieldBegin('messageId', TType::STRING, 1);
      $xfer += $output->writeString($this->messageId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->accessToken !== null) {
      $xfer += $output->writeFieldBegin('accessToken', TType::STRING, 2);
      $xfer += $output->writeString($this->accessToken);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->panPattern !== null) {
      $xfer += $output->writeFieldBegin('panPattern', TType::STRING, 3);
      $xfer += $output->writeString($this->panPattern);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TokenApi_ctsResetTidList_result {
  static $_TSPEC;

  /**
   * @var string[]
   */
  public $success = null;
  /**
   * @var \Prism\PrismToken1\ApiException
   */
  public $ex1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        1 => array(
          'var' => 'ex1',
          'type' => TType::STRUCT,
          'class' => '\Prism\PrismToken1\ApiException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['ex1'])) {
        $this->ex1 = $vals['ex1'];
      }
    }
  }

  public function getName() {
    return 'TokenApi_ctsResetTidList_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size58 = 0;
            $_etype61 = 0;
            $xfer += $input->readListBegin($_etype61, $_size58);
            for ($_i62 = 0; $_i62 < $_size58; ++$_i62)
            {
              $elem63 = null;
              $xfer += $input->readString($elem63);
              $this->success []= $elem63;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->ex1 = new \Prism\PrismToken1\ApiException();
            $xfer += $this->ex1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TokenApi_ctsResetTidList_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRING, count($this->success));
        {
          foreach ($this->success as $iter64)
          {
            $xfer += $output->writeString($iter64);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->ex1 !== null) {
      $xfer += $output->writeFieldBegin('ex1', TType::STRUCT, 1);
      $xfer += $this->ex1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}


